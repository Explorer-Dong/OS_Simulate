附录1(完整源代码)：
//模拟存储管理和访存1.0.cpp（多线程）
#include<pthread.h>
#include<semaphore.h>
#include<iostream>
using namespace std;
#include"unistd.h"
#include<time.h>
#include <Windows.h>
#include<fstream>
#include <cstdlib>
#include<graphics.h>
#include<stdio.h>
#include<random>
#define MemSize (1024*16)//内存大小(单位：字节）
#define PageSize 256//页面大小(单位：字节）
#define VirtualSpaceSize (1024*16)//每个作业的虚拟空间大小(单位：字节）
#define AllocatedMaxPageNum 9//每个作业分配的最大页数
sem_t S, mutex, recycle_mutex, allocate_mutex;//信号量
int free_framesnum = MemSize / PageSize;//空闲的页框数
struct VA//虚拟地址
{
	int page_id;//页号6位（0-63）
	int offset;//偏移量8位（0-255）
};
struct PA//物理地址
{
	int frame_id;//页框号6位（0-63）
	int offset;//偏移量8位（0-255）
};
struct Frame//页框
{
	char job;//作业名
	int loaded;//是否装入
	char data[PageSize];//数据
	Frame()
	{
		loaded = 0;
	}
};
struct PageTable//页表
{
	bool loaded[MemSize / PageSize];
	int physical_id[MemSize / PageSize];//块号
	PageTable()
	{
		for (int i = 0; i < MemSize / PageSize; i++)
		{
			loaded[i] = false;
			physical_id[i] = -1;
		}
	}
};
struct Job//作业
{
	char jobname;//作业名
	int pagetable_address;//页表所在的页框号
	struct PageTable pagetable;//页表
	char filename[10];//文件名（虚拟空间---磁盘）
};

struct Frame frames[MemSize / PageSize];//内存一共MemSize/PageSize个页框
struct Job jobs[12];//12个作业
void allocate(struct Job* job, ifstream& inFile)//分配函数,内存按顺序直接分配空闲空间，作业的前9页进内存,更新页表
{
	int num = 0;
	for (int i = 0; i < MemSize / PageSize; i++)//找到第一个空闲的页面，放页表
	{
		if (frames[i].loaded == 0)//空闲页面
		{
			frames[i].job = job->jobname;
			frames[i].loaded = 1;
			job->pagetable_address = i;
			strcpy(frames[i].data, "页表");
			break;
		}
	}
	for (int i = job->pagetable_address + 1; i < MemSize / PageSize; i++)//从页表占用的页框开始，分配9个空闲页框
	{
		if (frames[i].loaded == 0)//空闲页面
		{
			frames[i].job = job->jobname;
			frames[i].loaded = 1;
			inFile.seekg(num*PageSize, ios::beg);//把文件的读指针从文件开头向后移num*PageSize个字节
			inFile.read(frames[i].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
			//更新页表
			job->pagetable.loaded[num] = true;
			job->pagetable.physical_id[num] = i;
			num++;
		}
		if (num == 9) break;
	}
	free_framesnum = free_framesnum - 10;
}
void recycle(struct Job* job)//全部回收
{
	for (int i = 0; i < MemSize / PageSize; i++)
	{
		if ((frames + i)->loaded == 1 && (frames + i)->job == job->jobname)
		{
			(frames + i)->job = '\0';
			(frames + i)->loaded = 0;
			strcpy((frames + i)->data, "\0");
		}
	}
}
int LRU(struct Job* job, struct VA* vadr, int* queue_virtualid, ifstream& inFile)//最近最少用页面替换算法
{//队列共9个元素，不用管前后访存序列，只看本次访存地址在队列中的位置，如果有，和队首元素交换，如果没有，则缺页次数加1，从文件中重新调页，插入队首，其他后移，去除队尾。
	if (job->pagetable.loaded[vadr->page_id] == true)//在内存
	{
		sem_wait(&mutex);
		cout << job->jobname << "found!" << endl;
		cout << job->jobname << "虚拟页号：" << vadr->page_id << ",物理块号：" << job->pagetable.physical_id[vadr->page_id] << ",块内偏移：" << vadr->offset << endl;
		cout << job->jobname << "内容是:" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset]<<endl;//访问内存中该页面的内容
		sem_post(&mutex);
		//更新（找到当前地址，提出来放队首，剩下的往后移）
		int index=0;
		for (int i = 0; i < AllocatedMaxPageNum; i++)//找到要访问的当前地址
		{
			if (queue_virtualid[i] == vadr->page_id)
			{
				index = i;
				break;
			}
		}
		for (int i = index; i > 0; i--)//这个位置前面的都后移一位
		{
			queue_virtualid[i] = queue_virtualid[i - 1];
		}
		queue_virtualid[0] = vadr->page_id;//把当前地址放队首
		sem_wait(&mutex);
		cout << job->jobname << "当前访存队列的页号为："; for (int i = 0; i < AllocatedMaxPageNum; i++) cout << queue_virtualid[i] <<" "; cout << endl;
		sem_post(&mutex);
		return 0;
	}
	else//不在内存,缺页
	{
		//进入缺页中断处理
		sem_wait(&mutex);
		cout << job->jobname << "missing!" << endl;
		sem_post(&mutex);
		//更新页表
		job->pagetable.loaded[queue_virtualid[AllocatedMaxPageNum - 1]] = false;//队尾元素从内存移出
		job->pagetable.physical_id[vadr->page_id] = job->pagetable.physical_id[queue_virtualid[AllocatedMaxPageNum - 1]];//把队尾元素的页框分给当前访问地址对应的页面
		job->pagetable.physical_id[queue_virtualid[AllocatedMaxPageNum - 1]] = -1;
		job->pagetable.loaded[vadr->page_id] = true;//当前当前访问地址对应的页面进内存
		//更新内存!!!!!!!!
		inFile.seekg((vadr->page_id)*PageSize, ios::beg);//把文件的读指针从文件开头向后移到虚拟空间中当前地址对应的页面开头地址
		inFile.read(frames[job->pagetable.physical_id[vadr->page_id]].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
		sem_wait(&mutex);
		cout << job->jobname << "虚拟页号：" << vadr->page_id << ",物理块号：" << job->pagetable.physical_id[vadr->page_id] << ",块内偏移：" << vadr->offset << endl;
		cout << job->jobname << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访存
		sem_post(&mutex);
		//更新对列
		for (int i = AllocatedMaxPageNum - 1; i > 0; i--)//队列中前面元素全部后移一位
		{
			queue_virtualid[i] = queue_virtualid[i - 1];
		}
		queue_virtualid[0] = vadr->page_id;
		//缺页中断结束
		sem_wait(&mutex);
		cout << job->jobname << "当前访存队列的页号为："; for (int i = 0; i < AllocatedMaxPageNum; i++) cout << queue_virtualid[i] << " "; cout << endl;
		sem_post(&mutex);
		return 1;
	}
}
int FIFO(struct Job* job, struct VA* vadr, int* queue_virtualid, ifstream& inFile)//先进先出页面替换算法
{//队列共9个元素，不用管前后访存序列，只看本次访存地址在队列中的位置，如果有，ok，如果没有，则缺页次数加1，从文件中重新调页，插入队首，其他后移，去除队尾。
	if (job->pagetable.loaded[vadr->page_id] == true)//在内存
	{
		sem_wait(&mutex);
		cout << job->jobname << "found!" << endl;
		cout << job->jobname << "虚拟页号：" << vadr->page_id << ",物理块号：" << job->pagetable.physical_id[vadr->page_id] << ",块内偏移：" << vadr->offset << endl;
		cout << job->jobname << "内容是:" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访问内存中该页面的内容
		sem_post(&mutex);
		return 0;
	}
	else//不在内存,缺页
	{
		//进入缺页中断处理
		sem_wait(&mutex);
		cout << job->jobname << "missing!" << endl;
		sem_post(&mutex);
		//更新页表
		job->pagetable.loaded[queue_virtualid[AllocatedMaxPageNum - 1]] = false;//队尾元素从内存移出
		job->pagetable.physical_id[vadr->page_id] = job->pagetable.physical_id[queue_virtualid[AllocatedMaxPageNum - 1]];//把队尾元素的页框分给当前访问地址对应的页面
		job->pagetable.physical_id[queue_virtualid[AllocatedMaxPageNum - 1]] = -1;
		job->pagetable.loaded[vadr->page_id] = true;//当前当前访问地址对应的页面进内存
		//更新内存!!
		inFile.seekg(vadr->page_id * PageSize, ios::beg);//把文件的读指针从文件开头向后移到虚拟空间中当前地址对应的页面开头地址
		inFile.read(frames[job->pagetable.physical_id[vadr->page_id]].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
		sem_wait(&mutex);
		cout << job->jobname << "虚拟页号：" << vadr->page_id << ",物理块号：" << job->pagetable.physical_id[vadr->page_id] << ",块内偏移：" << vadr->offset << endl;
		cout << job->jobname << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访存
		sem_post(&mutex);
		//更新队列
		for (int i = AllocatedMaxPageNum - 1; i > 0; i--)//队列中前面元素全部后移一位
		{
			queue_virtualid[i] = queue_virtualid[i - 1];
		}
		queue_virtualid[0] = vadr->page_id;
		//缺页中断结束
		sem_wait(&mutex);
		cout << job->jobname << "当前访存队列的页号为："; for (int i = 0; i < AllocatedMaxPageNum; i++) cout << queue_virtualid[i] << " "; cout << endl;
		sem_post(&mutex);
		return 1;
	}
}

void* visit_Mem(void* str)//每个作业的线程函数
{
	sem_wait(&mutex);
	cout << "创建新线程" << endl;
	sem_post(&mutex);
	struct Job* job = (struct Job*)str;
	ifstream inFile;//文件读取
	inFile.open(job->filename);
	int pagemissing_num = 0;//缺页次数
	sem_wait(&allocate_mutex);//保证一个一个进来
	if (free_framesnum < 10)
	{
		sem_post(&allocate_mutex);
		cout << job->jobname << "等待！" << endl;
		sem_wait(&S);//内存不够，P操作加入等待队列
	}
	else sem_post(&allocate_mutex);
	//剩余页框数大于等于10个才分配
	sem_wait(&allocate_mutex);
	allocate(job, inFile);//分配内存
	sem_post(&allocate_mutex);
	sem_wait(&mutex);
	cout << job->jobname << "分配成功" << endl;
	sem_post(&mutex);
	//开始访存
	struct VA va[200]; //struct VA va[200];
	int queue_virtualid[AllocatedMaxPageNum];//访问队列，只有9个元素（9个虚拟空间中页面的下标）
	for (int i = 0; i < AllocatedMaxPageNum; i++)//初始化
	{
		queue_virtualid[i] = i;
	}
	for (int i = 0; i < 10; i++)//for (int i = 0; i < 200; i++)//生成200个随机逻辑地址
	{
		random_device e;

		va[i].page_id = e() % (MemSize / PageSize);//0-63
		va[i].offset = e() % PageSize;//0-255
	}
	for (int i = 0; i <10; i++)//for (int i = 0; i < 200; i++)
	{

		int flag=FIFO(job, &va[i], queue_virtualid,inFile);
		if (flag == 1)pagemissing_num++;//发生缺页
		Sleep(3);
	}
	sem_wait(&mutex);
	cout << job->jobname << "缺页次数：" << pagemissing_num << ", 缺页中断率：" << (double)pagemissing_num / 10 * 100 << "%\n";//输出缺页次数和缺页中断率
	sem_post(&mutex);

	sem_wait(&recycle_mutex);
	recycle(job);
	sem_post(&recycle_mutex);
	sem_wait(&mutex);
	cout <<job->jobname <<"回收完成" << endl;
	sem_post(&mutex);
	free_framesnum = free_framesnum + 10;
	sem_post(&S);//唤醒等待的作业

	return NULL;

}
int main()
{
	//初始化页框全为空
	for (int i = 0; i < MemSize / PageSize; i++)
	{
		(frames + i)->loaded = 0;
		(frames + i)->job = '\0';
	}
	//生成12个作业对应12个文件
	jobs[0].jobname = 'A'; strcpy(jobs[0].filename, "job1.dat");
	jobs[1].jobname = 'B'; strcpy(jobs[1].filename, "job2.dat");
	jobs[2].jobname = 'C'; strcpy(jobs[2].filename, "job3.dat");
	jobs[3].jobname = 'D'; strcpy(jobs[3].filename, "job4.dat");
	jobs[4].jobname = 'E'; strcpy(jobs[4].filename, "job5.dat");
	jobs[5].jobname = 'F'; strcpy(jobs[5].filename, "job6.dat");
	jobs[6].jobname = 'G'; strcpy(jobs[6].filename, "job7.dat");
	jobs[7].jobname = 'H'; strcpy(jobs[7].filename, "job8.dat");
	jobs[8].jobname = 'I'; strcpy(jobs[8].filename, "job9.dat");
	jobs[9].jobname = 'J'; strcpy(jobs[9].filename, "job10.dat");
	jobs[10].jobname = 'K'; strcpy(jobs[10].filename, "job11.dat");
	jobs[11].jobname = 'L'; strcpy(jobs[11].filename, "job12.dat");
	//生成用于该作业访存的线程
	pthread_t t[12];
	sem_init(&mutex, 0, 1);  //初始化其值为1
	sem_init(&recycle_mutex, 0, 1);  //初始化其值为1
	sem_init(&allocate_mutex, 0, 1);  //初始化其值为1
	sem_init(&S, 0, 0); //初始化其值为0
	for (int i = 0; i < 12; i++)
	{
		pthread_create(&t[i], NULL, visit_Mem, (void*)(&jobs[i]));
		//for (int i = 0; i < 64; i++) cout << frames[i].loaded << " ";
		//Sleep(20);
	}
    for (int i = 0; i < 12; i++) pthread_join(t[i], NULL);
	sem_destroy(&S);//销毁信号量
	sem_destroy(&mutex);//销毁信号量
	sem_destroy(&recycle_mutex);//销毁信号量
	sem_destroy(&allocate_mutex);
	return 0;
}

//模拟存储管理交互2.0.cpp
#include<pthread.h>
#include<semaphore.h>
#include<iostream>
using namespace std;
#include"unistd.h"
#include<time.h>
#include <Windows.h>
#include<fstream>
#include <cstdlib>
#include<graphics.h>
#include<stdio.h>
#define MemSize (1024*16)//内存大小(单位：字节）
#define PageSize 256//页面大小(单位：字节）
#define VirtualSpaceSize (1024*16)//每个作业的虚拟空间大小(单位：字节）
#define AllocatedMaxPageNum 9//每个作业分配的最大页数
sem_t S, mutex, x;//信号量
int free_framesnum = MemSize / PageSize;//空闲的页框数
struct VA//虚拟地址
{
	int page_id;//页号6位（0-63）
	int offset;//偏移量8位（0-255）
};
struct PA//物理地址
{
	int frame_id;//页框号6位（0-63）
	int offset;//偏移量8位（0-255）
};
struct Frame//页框
{
	char job;//作业名
	int loaded;//是否装入
	char data[PageSize];//数据
	Frame()
	{
		loaded = 0;
	}
};
struct PageTable//页表
{
	bool loaded[MemSize / PageSize];
	int physical_id[MemSize / PageSize];//块号
	PageTable()
	{
		for (int i = 0; i < MemSize / PageSize; i++)
		{
			loaded[i] = false;
			physical_id[i] = -1;
		}
	}
};
struct Job//作业
{
	char jobname;//作业名
	int pagetable_address;//页表所在的页框号
	struct PageTable pagetable;//页表
	char filename[10];//文件名（虚拟空间---磁盘）
	int queue_virtualid[AllocatedMaxPageNum];
};

struct Frame frames[MemSize / PageSize];//内存一共MemSize/PageSize个页框
struct Job jobs[12];//12个作业
void allocate(struct Job* job, ifstream& inFile)//分配函数,内存按顺序直接分配空闲空间，作业的前9页进内存,更新页表
{


	int num = 0;
	for (int i = 0; i < MemSize / PageSize; i++)//找到第一个空闲的页面，放页表
	{
		if (frames[i].loaded == 0)//空闲页面
		{
			//setfillcolor(RGB(255, rand() % 256, rand() % 256));
			fillrectangle(200,10+i*10,400 ,10+i*10+10);
			frames[i].job = job->jobname;
			frames[i].loaded = 1;
			job->pagetable_address = i;
			strcpy(frames[i].data, "页表");
			break;
		}
	}
	for (int i = job->pagetable_address + 1; i < MemSize / PageSize; i++)//从页表占用的页框开始，分配9个空闲页框
	{
		if (frames[i].loaded == 0)//空闲页面
		{
			//setfillcolor(RGB(255, rand() % 256, rand() % 256));
			fillrectangle(200, 10 + i * 10, 400, 10 + i * 10 + 10);
			frames[i].job = job->jobname;
			frames[i].loaded = 1;
			inFile.seekg(num * PageSize, ios::beg);//把文件的读指针从文件开头向后移num*PageSize个字节
			inFile.read(frames[i].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
			//更新页表
			job->pagetable.loaded[num] = true;
			job->pagetable.physical_id[num] = i;
			num++;
		}
		if (num == 9) break;
	}
	for (int i = 0; i < 9; i++) job->queue_virtualid[i] = i;
	free_framesnum = free_framesnum - 10;
}
void recycle(struct Job* job)
{
	for (int i = 0; i < MemSize / PageSize; i++)
	{
		if ((frames + i)->loaded == 1 && (frames + i)->job == job->jobname)
		{
			setfillcolor(BLACK);
			fillrectangle(200, 10 + i * 10, 400, 10 + i * 10 + 10);
			clearrectangle(200, 10 + i * 10, 400, 10 + i * 10 + 10);
			line(200, 10 + i * 10, 200, 10 + i * 10 + 10);
			line(400, 10 + i * 10, 400, 10 + i * 10 + 10);
			if (i == 0)line(200, 10, 400, 10);
			if (i == 99)line(200, 650, 400, 650);
			(frames + i)->job = '\0';
			(frames + i)->loaded = 0;
			strcpy((frames + i)->data, "\0");
		}
	}
}
int LRU(struct Job* job, struct VA* vadr, ifstream& inFile)//最近最少用页面替换算法
{//队列共9个元素，不用管前后访存序列，只看本次访存地址在队列中的位置，如果有，和队首元素交换，如果没有，则缺页次数加1，从文件中重新调页，插入队首，其他后移，去除队尾。
	if (job->pagetable.loaded[vadr->page_id] == true)//在内存
	{
		cout << "found!" << endl;
		cout << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访问内存中该页面的内容
		//更新（找到当前地址，提出来放队首，剩下的往后移）
		int index = 0;
		for (int i = 0; i < AllocatedMaxPageNum; i++)//找到要访问的当前地址
		{
			if (job->queue_virtualid[i] == vadr->page_id)
			{
				index = i;
				break;
			}
		}
		for (int i = index; i > 0; i--)//这个位置前面的都后移一位
		{
			job->queue_virtualid[i] = job->queue_virtualid[i - 1];
		}
		job->queue_virtualid[0] = vadr->page_id;//把当前地址放队首
		//for (int i = 0; i < AllocatedMaxPageNum; i++) cout << queue_virtualid[i] << " "; cout << endl;
		for (int i = 0; i < 9; i++)cout << job->queue_virtualid[i] << " "; cout << endl;
		return 0;
	}
	else//不在内存,缺页
	{
		//进入缺页中断处理
		cout << "missing!" << endl;
		cout << "进行缺页处理" << endl;
		//更新页表
		job->pagetable.loaded[job->queue_virtualid[AllocatedMaxPageNum - 1]] = false;//队尾元素对应的页面从页表移出
		job->pagetable.physical_id[vadr->page_id] = job->pagetable.physical_id[job->queue_virtualid[AllocatedMaxPageNum - 1]];//把队尾元素的页框分给当前访问地址对应的页面
		//setfillcolor(RGB(rand() % 256, rand() % 256, 255));
		//fillrectangle(200, 10 + job->pagetable.physical_id[vadr->page_id] * 10, 400, 10 + job->pagetable.physical_id[vadr->page_id] * 10 + 10);
		job->pagetable.physical_id[job->queue_virtualid[AllocatedMaxPageNum - 1]] = -1;
		job->pagetable.loaded[vadr->page_id] = true;//当前当前访问地址对应的页面进内存

		//for (int i = 0; i < 64; i++)cout << job->pagetable.loaded[i] << " "; cout << endl;
		//cout << "更新页表完成" << endl;
		//更新内存!!!
		inFile.seekg((vadr->page_id) * PageSize, ios::beg);//把文件的读指针从文件开头向后移到虚拟空间中当前地址对应的页面开头地址
		inFile.read(frames[job->pagetable.physical_id[vadr->page_id]].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
		cout << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访存
		//更新对列
		for (int i = AllocatedMaxPageNum - 1; i > 0; i--)//队列中前面元素全部后移一位
		{
			job->queue_virtualid[i] = job->queue_virtualid[i - 1];
		}
		job->queue_virtualid[0] = vadr->page_id;
		cout << "\n页表中页号访问队列："; for (int i = 0; i < 9; i++)cout << job->queue_virtualid[i] << " "; cout << endl;
		//缺页中断结束
		return 1;
	}
}
int FIFO(struct Job* job, struct VA* vadr, ifstream& inFile)//先进先出页面替换算法
{//队列共9个元素，不用管前后访存序列，只看本次访存地址在队列中的位置，如果有，ok，如果没有，则缺页次数加1，从文件中重新调页，插入队首，其他后移，去除队尾。
	if (job->pagetable.loaded[vadr->page_id] == true)//在内存
	{
		cout << "found!" << endl;
		cout << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset]<<endl;//访问内存中该页面的内容
		return 0;
	}
	else//不在内存,缺页
	{
		//进入缺页中断处理
		cout << "missing!" << endl;
		cout << "进行缺页处理" << endl;
		//更新页表
		job->pagetable.loaded[job->queue_virtualid[AllocatedMaxPageNum - 1]] = false;//队尾元素从内存移出
		job->pagetable.physical_id[vadr->page_id] = job->pagetable.physical_id[job->queue_virtualid[AllocatedMaxPageNum - 1]];//把队尾元素的页框分给当前访问地址对应的页面
		//setfillcolor(RGB(rand() % 256, rand() % 256, 255));
		//fillrectangle(200, 10 + job->pagetable.physical_id[vadr->page_id] * 10, 400, 10 + job->pagetable.physical_id[vadr->page_id] * 10 + 10);
		job->pagetable.physical_id[job->queue_virtualid[AllocatedMaxPageNum - 1]] = -1;
		job->pagetable.loaded[vadr->page_id] = true;//当前当前访问地址对应的页面进内存
		//更新内存!!
		inFile.seekg(vadr->page_id * PageSize, ios::beg);//把文件的读指针从文件开头向后移到虚拟空间中当前地址对应的页面开头地址
		inFile.read(frames[job->pagetable.physical_id[vadr->page_id]].data, PageSize);//读取文件的PageSize字节的数据进内存对应页框的地方。
		cout << "内容是：" << frames[job->pagetable.physical_id[vadr->page_id]].data[vadr->offset] << endl;//访存
		//更新队列
		for (int i = AllocatedMaxPageNum - 1; i > 0; i--)//队列中前面元素全部后移一位
		{
			job->queue_virtualid[i] = job->queue_virtualid[i - 1];
		}
		job->queue_virtualid[0] = vadr->page_id;
		cout << "\n页表中页号访问队列："; for (int i = 0; i < 9; i++)cout << job->queue_virtualid[i] << " "; cout << endl;
		//缺页中断结束
		return 1;
	}
}

void button(int x, int y, int w, int h, const char* text)
{
	setlinecolor(WHITE);//设置框边颜色
	setbkmode(TRANSPARENT);//设置字体背景透明
	setfillcolor(RGB(0, 191, 255));//设置填充颜色
	fillroundrect(x, y, x + w, y + h, 10, 10);//画一个按钮框

	char text_[50] = { 0 };
	strcpy(text_, text);
	settextcolor(WHITE);
	settextstyle(20, 0, "黑体");
	int tx = x + (w - textwidth(text_)) / 2;
	int ty = y + (h - textheight(text_)) / 2;
	outtextxy(tx, ty, text_);
}
int main()
{
	//初始化页框全为空
	for (int i = 0; i < MemSize / PageSize; i++)
	{
		(frames + i)->loaded = 0;
		(frames + i)->job = '\0';
	}
	//生成12个作业对应12个文件
	jobs[0].jobname = 'A'; strcpy(jobs[0].filename, "job1.dat");
	jobs[1].jobname = 'B'; strcpy(jobs[1].filename, "job2.dat");
	jobs[2].jobname = 'C'; strcpy(jobs[2].filename, "job3.dat");
	jobs[3].jobname = 'D'; strcpy(jobs[3].filename, "job4.dat");
	jobs[4].jobname = 'E'; strcpy(jobs[4].filename, "job5.dat");
	jobs[5].jobname = 'F'; strcpy(jobs[5].filename, "job6.dat");
	jobs[6].jobname = 'G'; strcpy(jobs[6].filename, "job7.dat");
	jobs[7].jobname = 'H'; strcpy(jobs[7].filename, "job8.dat");
	jobs[8].jobname = 'I'; strcpy(jobs[8].filename, "job9.dat");
	jobs[9].jobname = 'J'; strcpy(jobs[9].filename, "job10.dat");
	jobs[10].jobname = 'K'; strcpy(jobs[10].filename, "job11.dat");
	jobs[11].jobname = 'L'; strcpy(jobs[11].filename, "job12.dat");
	initgraph(800, 700, SHOWCONSOLE);//展示控制台
	button(50, 10, 100, 30, "退出");
	button(50, 50, 100, 30, "分配");
	button(50, 90, 100, 30, "访问");
	button(50, 130, 100, 30, "显示页表");
	button(50, 170, 100, 30, "回收");
	MOUSEMSG msg;
	rectangle(200, 10, 400, 650);
	outtextxy(230, 660, "内存");
	while (1)
	{
		if (MouseHit())//有鼠标操作消息返回真
		{
			msg = GetMouseMsg();//获取鼠标信息
			if (msg.uMsg == WM_LBUTTONDOWN)//消息分发
			{
				if (msg.x >= 50 && msg.x <= 50 + 100 && msg.y >= 10 && msg.y <= 10 + 30)//退出
				{

					printf("退出\n");
					break;
				}
				if (msg.x >= 50 && msg.x <= 50 + 100 && msg.y >= 50 && msg.y <= 50 + 30)//作业进内存，初始分配
				{
					cout << "*************分配内存空间**********************\n";
					ifstream inFile;//文件读取
					cout << "输入作业名：";
					char ch; int index;
					cin >> ch;
					for (int i = 0; i < 12; i++)
						if (jobs[i].jobname == ch)
						{
							index = i; break;
						}
					if (index<12 && index>-1)
					{
						inFile.open(jobs[index].filename);
						setfillcolor(RGB(rand() % 256, rand() % 256, rand() % 256));
						allocate(&jobs[index], inFile);
						printf("分配内存\n");
					}
				}
				if (msg.x >= 50 && msg.x <= 50 + 100 && msg.y >= 90 && msg.y <= 90 + 30)//访存，输入虚拟地址，访问内存
				{
					cout << "*************访存10次**********************\n";
					ifstream inFile;//文件读取
					cout << "输入作业名：";
					char ch; int index;
					cin >> ch;
					for (int i = 0; i < 12; i++)
						if (jobs[i].jobname == ch)
						{
							index = i; break;
						}
					if (index<12 && index>-1)
					{
						int pagemissing = 0;
						for (int i = 0; i < 10; i++)
						{
							cout << "输入虚拟地址：(\"页号\"和\"偏移量\"中间加一个空格）";
							struct VA va;
							cin >> va.page_id >> va.offset;
							inFile.open(jobs[index].filename);

							int d = LRU(&jobs[index], &va, inFile);
							if (d == 1)
							{
								pagemissing++;
								cout << "发生缺页！" << endl;
							}
						}
						cout << "缺页次数：" << pagemissing << ",缺页率：" << pagemissing * 10 << "%。" << endl;
					}
				}
				if (msg.x >= 50 && msg.x <= 50 + 100 && msg.y >= 130 && msg.y <= 130 + 30)//显示作业的页表
				{
					cout << "*************显示作业的页表**********************\n";
					cout << "输入作业名：";
					char ch; int index;
					cin >> ch;
					for (int i = 0; i < 12; i++)
						if (jobs[i].jobname == ch)
						{
							index = i; break;
						}
					if (index<12 && index>-1)
					{
						cout << "页表所在内存的页框号：" << jobs[index].pagetable_address << endl;
						clearrectangle(500, 10, 700, 650);
						rectangle(500, 10, 700, 650);
						outtextxy(530, 660, "页表");
						setfillcolor(BLACK);
						solidrectangle(500, 660, 530, 680);
						outtextxy(500, 660, jobs[index].jobname);
						setfillcolor(RGB(rand() % 256, rand() % 256, 255));
						for (int i = 0; i < 64; i++)
						{
							cout << jobs[index].pagetable.physical_id[i] << " ";
							if (jobs[index].pagetable.loaded[i] == true)
							{
								fillrectangle(500, 10 + i * 10, 700, 10 + i * 10 + 10);
							}
						}
						cout << endl;
						//for (int i = 0; i < 64; i++) cout << jobs[index].pagetable.loaded[i] << " ";
					}
				}
				if (msg.x >= 50 && msg.x <= 50 + 100 && msg.y >= 170 && msg.y <= 170 + 30)//回收
				{
					cout << "*************回收**********************\n";
					cout << "输入作业名：";
					char ch; int index;
					cin >> ch;
					for (int i = 0; i < 12; i++)
						if (jobs[i].jobname == ch)
						{
							index = i; break;
						}
					if (index<12 && index>-1)
					{
						recycle(&jobs[index]);
					}
				}
			}
		}
	}
	getchar();
	closegraph();
	return 0;
}
