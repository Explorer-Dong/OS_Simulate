# 进程与线程并发

## 实验环境

操作系统：Windows

g++ 版本：(MinGW-W64 x86_64-posix-seh, built by Brecht Sanders) 11.2.0

python版本：3.11.2

## 实验目的

#### 本实验将实现多线程统计单词数量. 

凡一个非数字或字母跟在数字或字母后面, 这个数字或字母被视为单词结尾.

本实验将使用两种方式完成上述任务, 并在小样本上可视化, 大样本上测试.

## 实验准备

###### 小样本文件

1. 包含 26 个字母:  a b c ... x y z
2. 包含两组 26 个字母:  a b c ... x y z a b c ... x y z
3. 包含 26 个字母重复 2 次:  aa bb cc ... xx yy zz
4. 包含 26 个字母重复 3 次:  aaa bbb ccc ... xxx yyy zzz

###### 大样本文件

使用 c++ 库中的 ``iostream``, ``vector`` 等文件.

## 实验方法

#### 方法一

两个线程共享一个全局变量 total_words

当一个线程扫描到一个单词时, 就更新 total_words 变量

对 total_words 变量的更新必须互斥访问, 因此, 需要使用 semaphore 信号量

最后主程序输出 total_words 即可

#### 方法二

两个变量不共享变量, 各自独立统计各自文件的单词数.

当线程结束后, 将统计的单词个数返回给主线程.

主程序等两个线程都结束后, 将两个返回值相加, 得到单词总数.

#### 可视化

线程向 ans.out 文件中输出每个单词结束时的时间.

可视化程序从 ans.out 中获取时间信息.

根据获取到的时间信息动态还原单词统计的过程.

## 实验步骤

1. 完成方法一的程序, 并在控制台上测试小样本. 

   例如使用命令:  `g++ solution1.cpp -o solution.exe && solution.exe word1.txt word2.txt`

2. 完成方法二的程序, 并在控制台上测试小样本.

   例如使用命令:  `g++ solution2.cpp -o solution.exe && solution.exe word1.txt word2.txt`

3. 完成可视化程序, 并测试小样本.

   例如使用命令:  `g++ solution1.cpp -o solution.exe && solution.exe word1.txt word2.txt && python main.py`

4. 测试大样本.
5. 扩展代码, 根据输入的文件数量创建相应数量的线程.
6. 测试小样本并可视化, 测试大样本.

## 实验结果

###### 方法一



## 实验分析

1. 由于 C++ 读写速度过快, 需要在每次 ``getchar`` 后停顿一段固定时间展示差异性. (此处是为了可视化效果, 在大样本测试中不需要)
2. 由于多个线程可能会同时结束, 向 `ans.out` 中写入信息时会错乱, 需要一个信号量互斥写入.

## 附录

实验代码已经上传到 github 仓库.